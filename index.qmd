---
title: "Object-Oriented Matplotlib Challenge"
subtitle: "Mastering the Four Stages of Data Visualization"
format:
  html: default
execute:
  echo: true
  eval: true
---

# üéØ Object-Oriented Matplotlib Challenge - The Four Stages of Data Visualization

::: {.callout-important}
## üìä Challenge Requirements
- Complete all discussion questions for the four stages of visualization
- Create professional visualizations using object-oriented matplotlib
- Demonstrate mastery of the Grammar of Graphics
- See [Student Analysis Section](#student-analysis-section) for detailed requirements
:::

## The Problem: Mastering Object-Oriented Matplotlib Through the Four Stages

**Core Question:** How can we create compelling, professional data visualizations using object-oriented matplotlib and the four stages of visualization?

**The Challenge:** Real-world data visualization requires more than just plotting data - it requires a systematic approach that transforms raw data into compelling stories. The four stages framework provides a proven methodology for creating visualizations that inform, persuade, and inspire action.

**Our Approach:** We'll work with baseball stadium data to investigate whether Coors Field in Denver, Colorado is truly the most run-friendly ballpark in Major League Baseball. This investigation will take us through all four stages of visualization, demonstrating object-oriented matplotlib techniques along the way.

::: {.callout-warning}
## ‚ö†Ô∏è AI Partnership Required

This challenge pushes boundaries intentionally. You'll tackle problems that normally require weeks of study, but with Cursor AI as your partner (and your brain keeping it honest), you can accomplish more than you thought possible.

**The new reality:** The four stages of competence are Ignorance ‚Üí Awareness ‚Üí Learning ‚Üí Mastery. AI lets us produce Mastery-level work while operating primarily in the Awareness stage. I focus on awareness training, you leverage AI for execution, and together we create outputs that used to require years of dedicated study.
:::

## The Four Stages of Data Visualization

The four essential stages for creating effective visualizations are:

1. **Stage 1: Declaration of Purpose** - Define your message and audience
2. **Stage 2: Curation of Content** - Gather and create all necessary data
3. **Stage 3: Structuring of Visual Mappings** - Choose geometry and aesthetics
4. **Stage 4: Formatting for Your Audience** - Polish for professional presentation

## Data and Business Context

We analyze Major League Baseball stadium data to investigate whether Coors Field in Denver, Colorado is truly the most run-friendly ballpark. This dataset is ideal for our analysis because:

- **Real Business Question:** Sports analysts and fans want to understand stadium effects on scoring
- **Clear Hypothesis:** High altitude should make Coors Field more run-friendly
- **Multiple Metrics:** We can analyze both total runs and home runs
- **Visualization Practice:** Perfect for demonstrating all four stages of visualization

## Data Loading and Initial Exploration

Let's start by loading the baseball data and understanding what we're working with.

```{python}
#| label: load-data
#| echo: true
#| message: false
#| warning: false

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns

# Load 2010 baseball season data
df2010 = pd.read_csv("baseball10.csv")

# Load 2021 baseball season data for comparison
df2021 = pd.read_csv("baseball21.csv")

print("2010 data shape:", df2010.shape)
print("2021 data shape:", df2021.shape)
print("\n2010 data columns:", df2010.columns.tolist())
print("\nFirst few rows of 2010 data:")
print(df2010.head())
```

::: {.callout-note}
## üí° Understanding the Data

**Baseball Game Data:** Contains information about each game, including:
- `home`: Home team (3-letter code)
- `visiting`: Visiting team (3-letter code)
- `homeScore`: Runs scored by home team
- `visScore`: Runs scored by visiting team
- `homeHR`: Home runs by home team
- `visHR`: Home runs by visiting team
- `date`: Game date

**Business Questions We'll Answer:**
1. Is Coors Field (COL) the most run-friendly ballpark in 2010?
2. How does this change in 2021?
3. What's the difference between total runs and home runs by stadium?
:::

## Stage 1: Declaration of Purpose

**Mental Model:** Start with a clear message and bold title that states your recommendation.

Our purpose is to investigate whether Coors Field in Denver, Colorado is truly the most run-friendly baseball stadium in Major League Baseball.

::: {.callout-important}
## ü§î Discussion Questions: Stage 1 - Declaration of Purpose

**Question 1: Hypothesis Formation**
- Why might high altitude affect baseball performance?  Is Coors Field affected by high altitude?

**Answer:**

High altitude affects baseball performance primarily because the air is thinner. This has several impacts:

1.  **Less air resistance:** The baseball travels faster and further with less air resistance. This is especially true for batted balls, leading to more home runs and extra-base hits.
2.  **Less movement on pitches:** Pitches like curveballs and sliders rely on air resistance to create their movement. In thinner air, these pitches have less break, making them easier for hitters to hit.
3.  **Physiological effects:** Some players may experience fatigue or shortness of breath due to the lower oxygen levels at high altitude, although professional athletes are generally well-conditioned.

Yes, Coors Field in Denver, Colorado, is significantly affected by high altitude. Denver is located over a mile above sea level, making Coors Field the highest-altitude ballpark in Major League Baseball. This is why it's often considered a "hitter's park" due to the increased number of runs and home runs scored there.

Below analysis investigates whether the matches held in 2010 and 2021 provide evidence to support the hypothesis.

:::

```{python}
# Calculate total runs for each game in 2010
df2010['totalRuns'] = df2010['homeScore'] + df2010['visScore']

# Group by home team and calculate the average total runs
avg_runs_2010 = df2010.groupby('home')['totalRuns'].mean()

# Get the top 5 highest scoring fields in 2010
top_5_2010 = avg_runs_2010.sort_values(ascending=False).head()

print("Top 5 highest scoring fields in 2010:")
print(top_5_2010)
# Calculate total runs for each game in 2010
df2021['totalRuns'] = df2021['homeScore'] + df2021['visScore']

# Group by home team and calculate the average total runs
avg_runs_2021 = df2021.groupby('home')['totalRuns'].mean()

# Get the top 5 highest scoring fields in 2010
top_5_2021 = avg_runs_2021.sort_values(ascending=False).head()

print("\nTop 5 highest scoring fields in 2021:")
print(top_5_2021)
```
**COL was the top-scoring field in 2010; however, BOS scored the most runs in 2021. Although the data doesn‚Äôt show a clear pattern, we can see that COL ranks among the top five scoring fields in both years. We will analyze further to conclude this hypothesis.**


## Stage 2: Curation of Content

**Mental Model:** Gather and create all the data you need to support your message.

Let's aggregate the data to get average runs per stadium:

```{python}
#| label: stage-2-content
#| echo: true

# Stage 2: Curation of Content
# Aggregate data to get average runs per stadium

# Process 2010 data
avgDF_2010 = (df2010
    .assign(totalRuns = lambda df: df.homeScore + df.visScore)
    .assign(totalHR = lambda df: df.homeHR + df.visHR)
    .drop(columns = ['date', 'visiting'])
    .groupby(['home'], as_index=False)
    .mean()
)

# Process 2021 data
avgDF_2021 = (df2021
    .assign(totalRuns = lambda df: df.homeScore + df.visScore)
    .assign(totalHR = lambda df: df.homeHR + df.visHR)
    .drop(columns = ['date', 'visiting'])
    .groupby(['home'], as_index=False)
    .mean()
)

print("2010 Stadium Averages (Top 5):")
print(avgDF_2010.head())
print("\n2021 Stadium Averages (Top 5):")
print(avgDF_2021.head())
```

::: {.callout-important}
## ü§î Discussion Questions: Stage 2 - Curation of Content

**Question 1: Data Aggregation Strategy**
- How many games are in the dataset? Why do we aggregate individual games into stadium averages before we start the visualization process?

**Answer:**

There are 2430 games in the `df2010` dataset and 2429 games in the `df2021` dataset. We can see this information by looking at the shape of the dataframes:
:::
```{python}
print("2010 data shape:", df2010.shape)
print("2021 data shape:", df2021.shape)
```
We aggregate individual games into stadium averages before visualization to understand the typical scoring environment at each stadium, rather than focusing on the results of individual games. Each game has unique factors (pitchers, hitters, weather, etc.) that influence the score. By averaging the scores across all games played at a stadium, we smooth out these game-specific variations and get a more stable measure of the stadium's overall effect on scoring. This allows us to compare stadiums based on their inherent run-friendliness, which is the core question we are investigating. Visualizing individual game scores for all stadiums would be overwhelming and make it difficult to identify patterns related to the stadiums themselves.


## Stage 3: Structuring of Visual Mappings

**Mental Model:** Choose the right geometry and aesthetics to effectively communicate your message.

Let's explore different visual approaches:

```{python}
#| label: stage-3-mapping-exploration
#| echo: true

# Stage 3: Structuring of Visual Mappings
# Explore different geometries and aesthetics

# Sort data for better visualization
avgDF_2010_sorted = avgDF_2010.sort_values('totalRuns', ascending=True)

# Create figure with subplots to compare approaches
fig, axes = plt.subplots(2, 2, figsize=(8, 6))

# Approach 1: Scatter plot (not ideal for categorical data)
axes[0,0].scatter(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns)
axes[0,0].set_title("Approach 1: Scatter Plot")
axes[0,0].set_xlabel("Stadium")
axes[0,0].set_ylabel("Average Runs")

# Approach 2: Horizontal bar chart (better for categorical data)
axes[0,1].barh(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns)
axes[0,1].set_title("Approach 2: Horizontal Bar Chart")
axes[0,1].set_xlabel("Average Runs")
axes[0,1].set_ylabel("Stadium")

# Approach 3: Vertical bar chart
axes[1,0].bar(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns)
axes[1,0].set_title("Approach 3: Vertical Bar Chart")
axes[1,0].set_xlabel("Stadium")
axes[1,0].set_ylabel("Average Runs")
axes[1,0].tick_params(axis='x', rotation=45)

# Approach 4: Highlight Colorado
colorado_colors = ["darkorchid" if stadium == "COL" else "lightgrey" 
                   for stadium in avgDF_2010_sorted.home]
axes[1,1].barh(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns, color=colorado_colors)
axes[1,1].set_title("Approach 4: Highlight Colorado")
axes[1,1].set_xlabel("Average Runs")
axes[1,1].set_ylabel("Stadium")

plt.tight_layout()
plt.show()
```

::: {.callout-important}
## ü§î Discussion Questions: Stage 3 - Structuring of Visual Mappings

**Question 1: Geometry Choices**
- Why is a horizontal bar chart better than a scatter plot for this data?
- When would you choose a vertical bar chart over horizontal?

**Answer:**

For this data, a horizontal bar chart is better than a scatter plot because we are comparing a quantitative variable (average runs) across a set of categorical variables (stadiums).

*   **Horizontal Bar Chart:** This chart type is excellent for comparing values across distinct categories when the category labels are long (like stadium names or codes). The length of each bar directly represents the average runs, making it easy to compare stadiums visually and see which ones have higher or lower averages. The horizontal orientation allows for clear labeling of each stadium.
*   **Scatter Plot:** A scatter plot is typically used to show the relationship between two quantitative variables. While you *could* use it with a categorical variable on one axis, it's not ideal for direct comparison of the categorical values. Each stadium would just be a single point, making it harder to quickly see and compare the average run values for all stadiums. The visual emphasis is on the distribution of points rather than the precise value for each category.

You would choose a vertical bar chart over a horizontal one when the category labels are short and you have many categories, or if you want to emphasize the magnitude of the values (as the y-axis often starts at zero). Vertical bar charts are also more conventional for displaying time-series data or distributions. However, for comparing many categories with potentially longer labels like stadium names, horizontal bar charts often provide better readability.

**Question 2: Aesthetic Mappings**
- What does the color highlighting accomplish in Approach 4?
- How does position (x/y) compare to color for encoding data?

**Answer:**

In Approach 4, the color highlighting of the "COL" bar accomplishes the following:

- **Draws Attention:** It immediately draws the viewer's eye to the bar representing Coors Field, which is the focus of the analysis.
- **Categorical Distinction:** It visually separates Coors Field from all other stadiums, emphasizing its unique status or the hypothesis being tested.
- **Aids Comparison:** While the position on the chart is the primary way to compare the average runs, the color highlighting makes it quicker and easier to find Coors Field and compare its value to the others.

Comparing position (x/y) to color for encoding data:

- **Position (x/y):** This is a fundamental and highly effective aesthetic for encoding quantitative data. Our eyes are very good at perceiving differences in position along a common scale. In the bar charts, the length of the bars (encoded by position on the x-axis for horizontal or y-axis for vertical) is the primary way we interpret the average runs. This provides a precise comparison of values.
- **Color:** Color is better suited for encoding categorical data or for highlighting specific data points as done in Approach 4. While color gradients can be used for quantitative data, it's generally less precise for value comparison than position. Our ability to distinguish subtle differences in color or perceive exact values from a color scale is not as strong as our ability to compare lengths or positions. In this example, color is used to categorize "COL" versus "other stadiums," not to represent the quantity of runs itself.

:::

## Stage 4: Formatting for Your Audience

**Mental Model:** Polish your visualization for professional presentation.

Let's create a publication-ready visualization:

```{python}
#| label: stage-4-formatting
#| echo: true

# Stage 4: Formatting for Your Audience
# Create a professional, publication-ready visualization

# Set style for professional appearance
plt.style.use("seaborn-v0_8-whitegrid")

# Create the main visualization
fig, ax = plt.subplots(figsize=(8, 6))

# Create color array for highlighting Colorado
colorado_colors = ["darkorchid" if stadium == "COL" else "lightgrey" 
                   for stadium in avgDF_2010_sorted.home]

# Create horizontal bar chart
bars = ax.barh(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns, color=colorado_colors)

# Add title and labels
ax.set_title("Colorado (COL) is the Most Run-Friendly Ballpark in 2010", 
             fontsize=16, fontweight='bold', pad=20)
ax.set_xlabel("Average Runs Per Game", fontsize=12)
ax.set_ylabel("Stadium (Home Team)", fontsize=12)

# Add legend
colorado_bar = plt.Rectangle((0,0),1,1, color="darkorchid", label="Colorado Rockies")
other_bar = plt.Rectangle((0,0),1,1, color="lightgrey", label="Other Stadiums")
ax.legend(handles=[colorado_bar, other_bar], loc='lower right', frameon=True)

# Add annotation for Colorado
colorado_index = avgDF_2010_sorted[avgDF_2010_sorted.home == "COL"].index[0]
colorado_runs = avgDF_2010_sorted[avgDF_2010_sorted.home == "COL"]["totalRuns"].iloc[0]
ax.annotate(f"COL: {colorado_runs:.2f} runs/game", 
            xy=(colorado_runs, colorado_index), 
            xytext=(colorado_runs + 0.5, colorado_index),
            arrowprops=dict(arrowstyle='->', color='darkorchid', lw=2),
            fontsize=10, fontweight='bold', color='darkorchid')

# Set x-axis to start from 0 for better comparison
ax.set_xlim(0, max(avgDF_2010_sorted.totalRuns) * 1.1)

# Add grid for easier reading
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Print summary statistics
print(f"\nSummary Statistics for 2010:")
print(f"Colorado (COL) average runs per game: {colorado_runs:.2f}")
print(f"League average runs per game: {avgDF_2010_sorted.totalRuns.mean():.2f}")
print(f"Colorado is {((colorado_runs / avgDF_2010_sorted.totalRuns.mean()) - 1) * 100:.1f}% above league average")
```

::: {.callout-important}
## ü§î Discussion Questions: Stage 4 - Formatting for Your Audience

**Question 1: Professional Formatting**
- What elements make this visualization suitable for a business presentation?
- Is the annotation on the visualization helpful?  Can you fix its placement?

**Answer:**

Several elements make this visualization suitable for a business presentation:

1.  **Clear and Concise Title:** The title "Colorado (COL) is the Most Run-Friendly Ballpark in 2010" is bold and directly addresses the core question, making the main takeaway immediately clear to the audience.
2.  **Appropriate Chart Type:** A horizontal bar chart is effective for comparing categorical data (stadiums) and their corresponding values (average runs), which is suitable for presenting performance metrics.
3.  **Axis Labels and Title:** The axes are clearly labeled ("Average Runs Per Game" and "Stadium (Home Team)") with a descriptive title, ensuring the audience understands what the chart represents.
4.  **Highlighting:** Highlighting "COL" with a distinct color draws attention to the key subject of the analysis, making it easy for the audience to locate and focus on the relevant data point.
5.  **Legend:** The legend explains the color coding, which is essential for understanding the highlighting.
6.  **Annotation:** The annotation provides the exact average runs for Coors Field, offering precise data to support the visual comparison.
7.  **Grid:** The grid lines help in reading the values more accurately across the bars.
8.  **Professional Style:** Using a style like "seaborn-v0_8-whitegrid" provides a clean and professional aesthetic.

Regarding the annotation, yes, it is helpful as it provides the exact numerical value for Coors Field, reinforcing the visual message. However, its placement could be improved. In the current visualization, the annotation text overlaps slightly with the bar itself and the arrow can be adjusted for better readability and aesthetics.

To fix its placement, you could adjust the `xytext` coordinates to move the text further away from the bar and potentially change the arrow properties (`arrowprops`) to ensure it points clearly to the end of the bar without being distracting. You might also consider the alignment of the text relative to the point it's annotating.

:::


## Advanced Object-Oriented Techniques

**Mental Model:** Use object-oriented matplotlib to create complex, reusable visualizations.

Let's create a comprehensive comparison between 2010 and 2021:

```{python}
#| label: advanced-oo-techniques
#| echo: true

# Advanced Object-Oriented Techniques
# Create a comprehensive comparison visualization

# Prepare data for comparison
comparison_data = pd.merge(
    avgDF_2010[['home', 'totalRuns']].rename(columns={'totalRuns': 'runs_2010'}),
    avgDF_2021[['home', 'totalRuns']].rename(columns={'totalRuns': 'runs_2021'}),
    on='home', how='inner'
)

## TODO: Create the visualization

```

```{python}
# Create a comprehensive comparison visualization using the dataframe comparison_data

plt.style.use("seaborn-v0_8-whitegrid")

# Sort data for consistency based on 2010 runs
comparison_data_sorted = comparison_data.sort_values('runs_2010', ascending=True).reset_index(drop=True)

# Create figure and axes
fig, ax = plt.subplots(figsize=(10, 15)) # Adjust figsize for better readability with more bars

# Set the positions for the bars
bar_height = 0.35
y_pos = np.arange(len(comparison_data_sorted))

# Create color array for highlighting Colorado for 2010 and 2021
colors_2010 = ["darkorchid" if stadium == "COL" else "lightgrey" for stadium in comparison_data_sorted['home']]
colors_2021 = ["darkorchid" if stadium == "COL" else "lightgrey" for stadium in comparison_data_sorted['home']]


# Create horizontal bar charts for 2010 and 2021 side-by-side
bars_2010 = ax.barh(y_pos - bar_height/2, comparison_data_sorted['runs_2010'], bar_height, label='2010', color=colors_2010)
bars_2021 = ax.barh(y_pos + bar_height/2, comparison_data_sorted['runs_2021'], bar_height, label='2021', color=colors_2021)


# Add labels and title
ax.set_xlabel("Average Runs Per Game", fontsize=12)
ax.set_ylabel("Stadium (Home Team)", fontsize=12)
ax.set_title("Comparison of Average Runs Per Game by Stadium (2010 vs 2021)",
             fontsize=16, fontweight='bold', pad=20)

# Set y-axis ticks and labels
ax.set_yticks(y_pos)
ax.set_yticklabels(comparison_data_sorted['home'])

# Add legend
ax.legend()

# Add grid
ax.grid(True, alpha=0.3)

# Optional: Add value labels to the bars for more precision
# for bars in [bars_2010, bars_2021]:
#     for bar in bars:
#         width = bar.get_width()
#         ax.annotate(f'{width:.2f}',
#                     xy=(width, bar.get_y() + bar.get_height() / 2),
#                     xytext=(5, 0),  # 5 points right of the tip
#                     textcoords="offset points",
#                     ha='left', va='center')


plt.tight_layout()
plt.show()


```

::: {.callout-important}
## ü§î Discussion Questions: Advanced Object-Oriented Techniques

**Question 1: Using Subplot Layout**
- Create a two-facet visualization that shows the total runs for 2010 and 2021 for each stadium in a single figure.  Highlight Colorado in the visualization.

```{python}
# Question 1: Using Subplot Layout
# Create a two-facet visualization that shows the total runs for 2010 and 2021 for each stadium in a single figure.
# Highlight Colorado in the visualization.

plt.style.use("seaborn-v0_8-whitegrid")

# Sort data for consistency based on 2010 runs
comparison_data_sorted = comparison_data.sort_values('runs_2010', ascending=True).reset_index(drop=True)

# Create figure and axes for the two facets
fig, axes = plt.subplots(1, 2, figsize=(16, 8), sharey=True) # Share y-axis for easier comparison

# Get the list of stadiums in the desired order
stadium_order = comparison_data_sorted['home']

# Function to create a single bar chart facet
def create_stadium_runs_facet(ax, data, year, stadium_order):
    # Create color array for highlighting Colorado
    colorado_colors = ["darkorchid" if stadium == "COL" else "lightgrey"
                       for stadium in data['home']]

    # Use the ordered index for plotting
    ax.barh(stadium_order, data[f'runs_{year}'], color=colorado_colors)

    # Add title and labels
    ax.set_title(f"Average Runs Per Game - {year}", fontsize=14, fontweight='bold')
    ax.set_xlabel("Average Runs", fontsize=12)
    if year == 2010: # Only add ylabel to the first subplot
        ax.set_ylabel("Stadium (Home Team)", fontsize=12)

    # Add grid
    ax.grid(True, alpha=0.3)


# Create facets for 2010 and 2021
create_stadium_runs_facet(axes[0], comparison_data_sorted, 2010, stadium_order)
create_stadium_runs_facet(axes[1], comparison_data_sorted, 2021, stadium_order)


# Add a main title to the figure
fig.suptitle("Comparison of Average Runs Per Game by Stadium (2010 vs 2021)",
             fontsize=18, fontweight='bold', y=1.02) # Adjust y for spacing

# Add a legend to the figure
colorado_bar = plt.Rectangle((0,0),1,1, color="darkorchid", label="Colorado Rockies")
other_bar = plt.Rectangle((0,0),1,1, color="lightgrey", label="Other Stadiums")
fig.legend(handles=[colorado_bar, other_bar], loc='upper right', bbox_to_anchor=(0.9, 0.95), frameon=True)


plt.tight_layout()
plt.show()

```

**Question 2: Explanation of the Visualization**
- Ask AI To Add A Paragraph Here To Explain The Visualization
- Does AI come to the right conclusion?  If not, why not?

**Answer:**

The visualization above compares the average runs per game for each MLB stadium in the 2010 and 2021 seasons. The horizontal bar charts allow for easy comparison of run averages across different stadiums, with the stadiums ordered by their average runs in 2010. Coors Field (COL) is highlighted in purple to draw attention to its performance in both years. In 2010, Coors Field clearly had the highest average runs per game. However, in 2021, while still among the highest, it is no longer the top stadium, with Boston (BOS) showing a slightly higher average. This suggests that while Coors Field consistently ranks as one of the most run-friendly ballparks, its relative standing can change from year to year, and other factors or team performance can influence which stadium has the highest average runs in a given season.

Based on the data presented in the visualization, the initial AI conclusion that "Colorado (COL) is the Most Run-Friendly Ballpark in 2010" is supported by the 2010 data. However, the broader implication that Coors Field is consistently *the* most run-friendly ballpark across different years is not fully supported, as the 2021 data shows Boston with a slightly higher average. Therefore, while Coors Field is consistently one of the most run-friendly, the AI's initial conclusion should be qualified to specify the year or acknowledge that other stadiums can surpass it in certain seasons.

:::

## Student Analysis Section: Mastering Object-Oriented Matplotlib {#student-analysis-section}

**Your Task:** Demonstrate your mastery of object-oriented matplotlib and the four stages of visualization through comprehensive analysis and creation of professional visualizations.

### Core Challenge: Four Stages Analysis

**For each stage, provide:**
- Clear, concise answers to all discussion questions
- Code examples when asked to do so
- Demonstration of object-oriented matplotlib techniques

### Professional Visualizations (For 100% Grade)

**Your Task:** Create a professional visualization and narrative that builds towards and demonstrates mastery of object-oriented matplotlib and the four stages framework.

**Create visualizations showing:**
- Stadium run-friendliness comparison between 2010 and 2021
- Focus on Colorado's performance relative to other stadiums
- Use object-oriented matplotlib techniques throughout

**Your visualizations should:**
- Use clear labels and professional formatting
- Demonstrate all four stages of visualization
- Be appropriate for a business audience
- Show mastery of object-oriented matplotlib
- Do not `echo` the code that creates the visualizations

## Getting Started: Repository Setup üöÄ

::: {.callout-important}
## üìÅ Getting Started

**Step 1:** Fork and clone this challenge repository: `https://github.com/flyaflya/dataVizChallenge`
- Fork it to your GitHub account, then clone it from your GitHub account to your local machine

**Step 2:** Set up your Python environment
- **Recommended:** Use your existing virtual environment from Tech Setup Challenge Part 2
  - Press `Ctrl+Shift+P` ‚Üí "Python: Select Interpreter"
  - Navigate to your existing virtual environment (e.g., `your-previous-project/venv/Scripts/python.exe`)
  - Install additional packages: `pip install pandas numpy matplotlib seaborn`
- **Alternative:** Create a new virtual environment following [Quarto documentation](https://quarto.org/docs/projects/virtual-environments.html)

**Step 3:** You're ready to start! The data loading code and starter code for the visualizations are already provided in this file.

**Note:** This challenge uses the same `index.qmd` file you're reading right now - you'll edit it to complete your analysis.
:::

::: {.callout-warning}
## ‚ö†Ô∏è Cloud Storage Warning

**Avoid using Google Drive, OneDrive, or other cloud storage for Python projects!** These services can cause issues with package installations and virtual environment corruption. Keep your Python projects in a local folder like `C:\Users\YourName\Documents\` instead.
:::

::: {.callout-note}
## üéØ Object-Oriented Matplotlib Philosophy

*Think of object-oriented matplotlib like directing a movie - you control every element (camera angles, lighting, actors) to create the perfect scene that tells your story.*
:::

::: {.callout-warning}
## üíæ Important: Save Your Work Frequently!

**Before you start:** Make sure to commit your work often using the Source Control panel in Cursor (Ctrl+Shift+G or Cmd+Shift+G). This prevents the AI from overwriting your progress and ensures you don't lose your work.

**Commit after each major step:**
- After completing each stage section
- After adding your visualizations
- After completing your advanced object-oriented techniques
- Before asking the AI for help with new code

**How to commit:**
1. Open Source Control panel (Ctrl+Shift+G)
2. Stage your changes (+ button)
3. Write a descriptive commit message
4. Click the checkmark to commit

*Remember: Frequent commits are your safety net!*
:::

## Grading Rubric üéì

**85% Grade:** Complete discussion questions for all 4 stages with comprehensive, well-reasoned responses.

**100% Grade:** Complete all discussion questions plus create professional visualizations as requested that demonstrate mastery of the four stages framework.

## Submission Checklist ‚úÖ

**Minimum Requirements (Required for Any Points):**

- [ ] Fork repository named "dataVizChallenge" to your GitHub account
- [ ] Clone repository locally using Cursor (or VS Code)
- [ ] Completed discussion questions for at least 3 of the 4 stages
- [ ] Document rendered to HTML successfully
- [ ] HTML files uploaded to your repository
- [ ] GitHub Pages enabled and working
- [ ] Site accessible at `https://[your-username].github.io/dataVizChallenge/`

**85% Grade Requirements:**

- [ ] Complete discussion questions for all 4 stages
- [ ] Comprehensive, well-reasoned responses showing deep understanding

**100% Grade Requirements:**

- [ ] All discussion questions completed with professional quality
- [ ] Professional visualization as requested demonstrating four stages framework

**Report Quality (Critical for Higher Grades):**

- [ ] Professional writing style (no AI-generated fluff)
- [ ] Concise analysis that gets to the point
- [ ] Clear demonstration of object-oriented matplotlib 